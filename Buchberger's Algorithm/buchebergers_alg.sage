import itertools

class GroebnerBasis:
    """
    Finds Groebner basis using Buchberger's algorithm.
    param: generating_polynoms: example; the ideal generated by [x**2 + 2*x*y**2, x*y + 2*y**3 - 1]
    """

    def __init__(self, generating_polynoms):
        self.gb = generating_polynoms
        self.pre_reduced()
        print("\nPre-Reduced", self.gb)
        self.minimal()
        print("Minimal", self.gb)
        self.reduced()
        print("Reduced", self.gb)
    
    @staticmethod
    def __s_polynomial(f, g):
        """
        params: f, g: polynomials
        return: S-polynomial(f, g)
        """
        gamma = lcm(f.lm(), g.lm())
        f_mult, g_mult = gamma//f.lt(), gamma//g.lt()
        return expand(f_mult*f - g_mult*g), f_mult, g_mult

    def __div_alg(self, functions, f, g):
        """
        Multivariate division of functions on S-poly(f, g). 
        param: functions: list[polynomials]
        param: f, g: two polynomials in functions
        return: divides: type(bool): 
            True: if remainder of S-poly on set = 0
            False: otherwise
        """
        f_idx, g_idx = functions.index(f), functions.index(g)
        s_poly = self.__s_polynomial(f, g)
        divides = False
        print("S({}, {}) = {}".format(f, g, s_poly[0]))

        try:
            mult = s_poly[0].lift(Ideal(functions))
            if s_poly[1] != mult[f_idx] and s_poly[2] != mult[g_idx]:  # if not generated by the def of s-polynom
                divides = True
                print("{} =  {} * {}^T, \n" .format(s_poly[0], mult, functions))
            else:
                print("Non-zero Remainder. Add to Basis \n")
        except ValueError:  # does not divide
            print("Non-zero Remainder. Add to Basis \n")

        return divides

    def pre_reduced(self):
        """ Loops over S-pairs, adding S-polys to basis if remainder on basis != 0. """
        indices = [i for i in itertools.combinations([i for i in range(len(self.gb))], 2)]
        for idx in indices:
            f, g = self.gb[idx[0]], self.gb[idx[1]]
            print("Basis", self.gb)
            if not self.__div_alg(self.gb, f, g):  # s-poly not in ideal
                self.gb += [self.__s_polynomial(f, g)[0]]
                indices += [(i, len(self.gb)-1) for i in range(len(self.gb)-1)]
        
    def minimal(self):
        """ Removes all polynomials whose leading term is in the ideal generated by
            the leading terms of all the other polynomials. """
        lt_gb = [polynom.lt() for polynom in self.gb]  # leading term groebner basis
        for term in lt_gb[::-1]:
            cp_lt_gb = copy(lt_gb)
            cp_lt_gb.remove(term)
            if term in ideal(cp_lt_gb):
                self.gb.pop(lt_gb.index(term))

    def reduced(self):
        """ Makes all leading coefficients 1. """
        for i in range(len(self.gb)):
            polynom = self.gb[i]
            self.gb[i] /= polynom.lc()
        
